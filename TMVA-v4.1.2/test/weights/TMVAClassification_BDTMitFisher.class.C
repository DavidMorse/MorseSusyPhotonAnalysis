// Class: ReadBDTMitFisher
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTMitFisher
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.32/00       [335872]
Creator        : dmorse
Date           : Wed Dec 12 17:05:53 2012
Host           : Linux lxbuild170.cern.ch 2.6.18-308.1.1.el5 #1 SMP Wed Mar 7 19:25:07 CET 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/user/d/dmorse/scratch0/RA3/2012/cms533v1/CMSSW_5_3_3/src/TMVA-v4.1.2/test
Training events: 105866
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
AdaBoostBeta: "5.000000e-01" [Parameter for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "150" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "20" [Number of steps during node cut optimisation]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "3" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "105866" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
TotEt                         TotEt                         TotEt                         TotEt                                                           'F'    [142.770004272,5517.5]
dPhi                          dPhi                          dPhi                          dPhi                                                            'F'    [0.0504544004798,3.14159011841]
PhotonLessHt                  PhotonLessHt                  PhotonLessHt                  PhotonLessHt                                                    'F'    [56.6633987427,4457.33007812]
DiEMPt                        DiEMPt                        DiEMPt                        DiEMPt                                                          'F'    [0.0673222988844,1843.01000977]
InvarMass                     InvarMass                     InvarMass                     InvarMass                                                       'F'    [20.2073993683,3072]
Met                           Met                           Met                           Met                                                             'F'    [0.0871639996767,1953.14001465]
SystemMETdPhi                 SystemMETdPhi                 SystemMETdPhi                 SystemMETdPhi                                                   'F'    [1.26998002088e-05,3.14152002335]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTMitFisherNode
   
#ifndef BDTMitFisherNode__def
#define BDTMitFisherNode__def
   
class BDTMitFisherNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTMitFisherNode ( BDTMitFisherNode* left,BDTMitFisherNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
   }

   virtual ~BDTMitFisherNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTMitFisherNode*   fLeft;     // pointer to the left daughter node
   BDTMitFisherNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTMitFisherNode::~BDTMitFisherNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] > fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTMitFisher : public IClassifierReader {

 public:

   // constructor
   ReadBDTMitFisher( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTMitFisher" ),
        fNvars( 7 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TotEt", "dPhi", "PhotonLessHt", "DiEMPt", "InvarMass", "Met", "SystemMETdPhi" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 142.770004272461;
      fVmax[0] = 5517.5;
      fVmin[1] = 0.0504544004797935;
      fVmax[1] = 3.1415901184082;
      fVmin[2] = 56.6633987426758;
      fVmax[2] = 4457.330078125;
      fVmin[3] = 0.0673222988843918;
      fVmax[3] = 1843.01000976562;
      fVmin[4] = 20.2073993682861;
      fVmax[4] = 3072;
      fVmin[5] = 0.0871639996767044;
      fVmax[5] = 1953.14001464844;
      fVmin[6] = 1.2699800208793e-05;
      fVmax[6] = 3.14152002334595;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTMitFisher() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTMitFisherNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTMitFisher::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTMitFisherNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTMitFisherNode*)current->GetRight();
         else current=(BDTMitFisherNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDTMitFisher::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(3.34322228521842);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 97.2335, 0, 1, 0.996835,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.999265,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.00253312,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 113.454, 0, 0, 0.322231,-99) , 
8, 0.000719985, 0, -0.000510645, 0, 0, 0, 0, -0.675273, 7, -0.198853, 0, 0, 0.971335,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 116.966, 0, 1, 0.931708,-99) , 
NN(
0, 
0, 
8, 1.11314e-05, 0.00151057, -1.05907e-05, 5.32147e-05, 0, 0, 0, -0.0107662, -1, 0.00181429, 0, -1, 5.17639e-05,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 94.6841, 0, 0, 0.00577488,-99) , 
8, 0.000493138, 0, -0.00023376, 0, 0, 0, 0, -0.543462, 7, -0.111234, 0, 0, 0.288407,-99)    );
  // itree = 1
  fBoostWeights.push_back(2.59768);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.000104177, 0, -5.64541e-05, 0, -4.59176e-06, 0, 0, -0.128813, -1, -0.0366235, 0, 1, 0.999305,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.990727,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.132921,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 226.92, 0, 0, 0.437483,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1439.19, 0, 0, 0.96951,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.84663, 1, 1, 0.999018,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 61.7408, 0, -1, 0.00563901,-99) , 
8, 0.000187347, 0, -0.000171793, 0, 0, 0, 0, -0.109295, 7, 0.023647, 0, 0, 0.022184,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.280378,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.85602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 83.5981, 0, 1, 0.9444,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.702006,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.00423863,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 122.472, 0, 0, 0.295094,-99) , 
8, 0.000645462, 0, -0.000135641, 0, 0, 0, 0, -1.00261, 7, -0.389343, 0, 0, 0.905944,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.891565,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.310054,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3.09538, 1, 0, 0.750273,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.00166462,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 372.097, 0, 0, 0.00450335,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 237.047, 0, 0, 0.0212544,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 87.8265, 0, 0, 0.323749,-99)    );
  // itree = 3
  fBoostWeights.push_back(1.85358);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 941.727, 0, 1, 0.985205,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.867387,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.367208,-99) , 
8, 0.00269606, 0, -0.00250629, 0, 0, 0, 0, -0.83736, 7, -0.0509692, 0, 0, 0.609588,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 170.607, 0, 0, 0.926305,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.983956,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 0.000869876, 0, -0.000650717, 0, 0, 0, 0, -0.544328, 7, -0.139105, 0, 0, 0.918669,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.9185,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0127199,-99) , 
8, 0.000291443, 0, -0.000213077, 0, 0, 0, 0, -0.187927, 7, 0.0548867, 0, 0, 0.0301562,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 62.0128, 0, 0, 0.0780864,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.2975,-99)    );
  // itree = 4
  fBoostWeights.push_back(1.18852);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.000149417, 0.21772, -0.000168616, 0.00103, 0.000259446, 0.000597284, 0.110456, -1.14432, -1, -0.163343, 0, 1, 0.94923,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.79588,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.405629,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.96225, 1, 0, 0.664705,-99) , 
8, 0.000494356, 0, -0.000152858, 0, 0, 0, 0, -0.735893, 7, -0.0391618, 0, 0, 0.847725,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.907617,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.110463,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 139.172, 0, 0, 0.76093,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.701065,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.053385,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.347351, 1, 0, 0.0814564,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 53.1663, 0, 0, 0.131627,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.341832,-99)    );
  // itree = 5
  fBoostWeights.push_back(1.03092);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 303.964, 0, 1, 0.864553,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.856026,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.201134,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 858.979, 0, 0, 0.343647,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 938.2, 0, 0, 0.761807,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.919804,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45945,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.749184, 1, 0, 0.577717,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 93.0897, 0, -1, 0.0387939,-99) , 
8, 0.000122621, -0.0298653, -9.81746e-05, 0.00181016, 0, 0, 0, -0.205962, 7, 0.0385854, 0, 0, 0.125648,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 165.531, 0, 0, 0.379527,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.894212);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -0.000223858, -0.175974, 0.000626665, 0, 0, 0, 0, 0.160941, -1, -0.087, 0, 1, 0.952825,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.796971,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.294318,-99) , 
8, -0.0039142, 0, 0.00360328, 0, 0, 0, 0, 1.20672, 7, -0.0465654, 0, 0, 0.59641,-99) , 
8, 0.000730761, 0, -0.000754266, 0, 0, 0, 0, -0.244175, 7, -0.0424911, 0, 0, 0.757351,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.738959,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.335911,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 39.8965, 0, 0, 0.464017,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 0.000827643, 0, -0.000497648, 0, 0, 0, 0, -0.599055, 7, -0.125724, 0, 0, 0.204583,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.412755,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.773339);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.94198,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.264121,-99) , 
8, -0.00015671, -0.359825, 0.000685594, 0, 0.000918088, 0.00022396, 0.237692, -0.863387, 7, -0.462887, 0, 0, 0.895613,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.763471,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.371713,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1116.15, 1, 0, 0.508598,-99) , 
8, 0.000755663, 0, -0.000452101, 0, 0, 0, 0, -0.71995, 7, 0.0648503, 0, 0, 0.624343,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.868954,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.424441,-99) , 
8, 0.00484087, 0, -0.00319672, 0, 0, 0, 0, -2.05001, 7, 0.00254109, 0, 0, 0.709025,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.514083,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 64.6402, 0, 0, 0.00486122,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 75.552, 0, 0, 0.140167,-99) , 
8, 0.000865728, 0, -0.000447886, 0, 0, 0, 0, -0.772155, 7, -0.193493, 0, 0, 0.446407,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.498173);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 351.322, 0, 1, 0.632373,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.753079,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 71.7116, 0, -1, 0.0048962,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 100.705, 0, 0, 0.183023,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1166.53, 0, 0, 0.488093,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.664163);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -4.14378e-06, -0.202686, 0.000380857, -0.000188294, 0.000826631, 0.000961438, 0.145537, -0.786002, -1, -0.105475, 0, 1, 0.954877,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.340188,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 483.948, 0, 0, 0.503583,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 159.032, 0, 0, 0.711251,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.887276,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.366921,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299157, 1, 0, 0.436984,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.840487,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0130531,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1502.88, 0, 0, 0.0795584,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6549, 0, 0, 0.3142,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 186.092, 0, 0, 0.416367,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.58433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.000348058, -0.230428, -2.67324e-05, -0.000380582, 0, 0, 0, -0.00132517, -1, -0.0372335, 0, 1, 0.938569,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.660076,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.32136,-99) , 
8, 0.00191223, 0, -0.00183184, 0, 0, 0, 0, -0.543571, 7, -0.0667858, 0, 0, 0.524332,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 311.302, 0, 0, 0.600331,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.850452,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.40823,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.23542, 1, 0, 0.606671,-99) , 
NN(
0, 
0, 
8, -0.000101817, -0.00981843, 0.000115999, -0.000204038, 0.000219455, -2.79421e-06, 0.00350602, -0.0364349, -1, -0.0268822, 0, -1, 0.00829241,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 49.9039, 0, 0, 0.269417,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 894.886, 0, 0, 0.500003,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.455286);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.717549,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.343849,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 135.29, 0, 0, 0.612705,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 535.977, 0, 0, 0.665196,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.523938,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0597019,-99) , 
8, 0.000746638, 0, -0.000470594, 0, 0, 0, 0, -0.595422, 7, -0.150942, 0, 0, 0.446307,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 0.000916937, 0, -0.000453891, 0, 0, 0, 0, -0.811725, 7, -0.254036, 0, 0, 0.341171,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.490596,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.475433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -0.000309423, 0, 0.000789383, 0, 0, 0, 0, -0.549402, -1, 0.098318, 0, 1, 0.865841,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461347,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 487.201, 0, 0, 0.540299,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 89.3763, 1, 0, 0.620581,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.843131,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.351178,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299141, 1, 0, 0.406489,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.584068,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0156199,-99) , 
8, 0.000160418, 0, 8.79577e-05, 0, 0, 0, 0, -0.375409, 7, 0.0368821, 0, 0, 0.0784139,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6267, 0, 0, 0.293068,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.442022,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.432743);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 352.421, 0, 1, 0.667229,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.716552,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.379883,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.84745, 0, 0, 0.496657,-99) , 
NN(
0, 
0, 
8, 0.000231944, 0, 2.13193e-05, 0, 0, 0, 0, -0.402936, -1, -0.00135976, 0, -1, 0.0838184,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6267, 0, 0, 0.367325,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 93.0897, 0, 0, 0.507343,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.28496);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1740.11, 0, 1, 0.9981,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.243986,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 491.427, 0, 0, 0.602375,-99) , 
8, 0.00074853, -0.376298, -0.000560462, -0.000860695, 0.000162724, 0.000670214, -0.156561, 0.325252, 7, -0.197616, 0, 0, 0.972922,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461341,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 522.052, 0, 0, 0.482387,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.807215,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0210001,-99) , 
8, 0.000873321, 0, -0.00061217, 0, 0, 0, 0, -0.518447, 7, 0.0262277, 0, 0, 0.152132,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 33.4991, 0, 0, 0.440922,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 351.104, 0, 0, 0.486141,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.27986);
  fForest.push_back( 
NN(
NN(
0, 
0, 
8, 9.82704e-05, -0.278476, 5.65335e-05, 0, 0.000385801, 0.000617264, -0.154862, 0.1511, -1, -0.219978, 0, 1, 0.972426,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.638033,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.460202,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2.09431, 0, 0, 0.536886,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.744998,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, -6.43277e-05, 0.0451177, 6.15943e-05, 0.0024523, 0, 0, 0, -0.264009, 7, 0.0298809, 0, 0, 0.0324002,-99) , 
8, 0.000542307, 0, -0.00044402, 0, 0, 0, 0, -0.269542, 7, -0.130322, 0, 0, 0.504006,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 351.104, 0, 0, 0.5397,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.361633);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.000554216, -0.139996, -0.000252039, -0.000597016, 0.000180082, 0.0007075, 0.0594215, -0.611204, -1, -0.0665419, 0, 1, 0.968433,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.290461,-99) , 
8, 0.000515795, 0.152908, 0.000134023, 0.000100308, 0, 0.000900627, 0.0443827, -1.87574, 7, 0.11183, 0, 0, 0.480312,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.84713, 1, 0, 0.829682,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.66419,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.439707,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1335.01, 1, 0, 0.535603,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1371.25, 0, -1, 0.0818782,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 24.2499, 0, 0, 0.498571,-99) , 
8, 0.000763477, 0, -0.000590968, 0, 0, 0, 0, -0.446711, 7, 0.132215, 0, 0, 0.548314,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.273914);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -5.36258e-05, -0.0606175, 0.000176722, -7.5136e-05, 0.000247228, 0.000155325, -0.0228118, -0.106686, -1, -0.0343178, 0, 1, 0.996737,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.999429,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.332539,-99) , 
8, -0.000916463, -0.621675, 0, -0.000203436, 0.00144381, 0.00271918, 0.199664, 1.05739, 7, 0.168071, 0, 0, 0.735118,-99) , 
8, 0.000283484, 0, -4.03122e-05, 0, -0.000110452, 0, -0.246208, -0.0054769, 7, -0.169533, 0, 0, 0.956234,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.299193, 1, 1, 0.570871,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.829747,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0404001,-99) , 
8, 0.000950541, 0, -0.000594743, 0, 0, 0, 0, -0.649166, 7, 0.0912934, 0, 0, 0.207222,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 33.4991, 0, 0, 0.532356,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 351.104, 0, 0, 0.560598,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.371375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -6.13485e-05, -0.0692865, 0.000202168, -8.59573e-05, 0.000282763, 0.000177673, -0.0260865, -0.122094, -1, -0.0391826, 0, 1, 0.995713,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.999231,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.414095,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1167.47, 1, 0, 0.745472,-99) , 
8, 0.000274646, 0, -3.0863e-05, 0, -9.40511e-05, 0, -0.237814, -0.024579, 7, -0.1637, 0, 0, 0.955672,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.9487,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.279649,-99) , 
8, -0.000194402, -0.285071, 0.00074104, 0, 0.00116695, -0.000719333, 0.381389, -1.03343, 7, -0.22238, 0, 0, 0.734488,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.935363,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.397571,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 362.574, 0, 0, 0.434445,-99) , 
8, 0.000634112, 0, -0.000377232, 0, 0, 0, 0, -0.488119, 7, 0.148251, 0, 0, 0.474927,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 351.104, 0, 0, 0.503852,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.242271);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1284.44, 0, 1, 0.9956,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.986815,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.420082,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.45717, 1, 0, 0.790888,-99) , 
8, 0.000161478, 0, 5.52132e-05, 0, -5.69098e-05, 0.000600324, -0.216592, -0.0401258, 7, -0.0745335, 0, 0, 0.954682,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.299193, 1, 1, 0.570785,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.753648,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0487995,-99) , 
8, 0.00095452, 0, -0.000547652, 0, 0, 0, 0, -0.710785, 7, 0.0664819, 0, 0, 0.231393,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 33.4991, 0, 0, 0.541408,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 351.104, 0, 0, 0.563442,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.466904);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.982225,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.315857,-99) , 
8, -0.00193961, -0.0769161, 0.00219517, 0.00133113, 0.00135884, 0.000538937, -0.0373942, 0.0774206, 7, -0.554902, 0, 0, 0.963916,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.884333,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.255014,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 95.3696, 1, 0, 0.438563,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 178.802, 0, 0, 0.727203,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.598635,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.265238,-99) , 
8, -0.00104575, 0, 0.000628712, 0, 0, 0, 0, 0.739444, 7, -0.154918, 0, 0, 0.511209,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.940579,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.104597,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 145.082, 0, 0, 0.23033,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 64.8908, 0, 0, 0.463421,-99) , 
8, 0.000701403, 0, -0.000509229, 0, 0, 0, 0, -0.440747, 7, 0.103595, 0, 0, 0.511254,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.432003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.449863, 1, 1, 0.99466,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.968611,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45727,-99) , 
8, 0.00113494, 0, -0.00063375, 0, 0, 0, 0, -1.2582, 7, 0.140802, 0, 0, 0.542032,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.492035, 1, 0, 0.61331,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.786127,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396754,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 852.391, 0, 0, 0.560571,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 109.95, 0, -1, 0.240136,-99) , 
8, 0.000741112, 0, -0.000930576, 0, 0, 0, 0, -0.0185996, 7, -0.030522, 0, 0, 0.396961,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1678.41, 0, 0, 0.476099,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.431424);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.000759669, -0.415319, -0.00017164, -0.00124217, 0.00110132, 0, 1.61198, -0.810186, -1, -0.174644, 0, 1, 0.987068,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.686316,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.317122,-99) , 
8, 0.000947669, 0, -0.000502165, 0, 0, 0, 0, -1.07314, 7, -0.144861, 0, 0, 0.616386,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299223, 1, 0, 0.668918,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 148.382, 0, 1, 0.616549,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.55832,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.045625,-99) , 
8, 0.000423436, 0.31007, -0.000163321, 0.0022026, 0, 0, 0, -1.30043, 7, -0.0132909, 0, 0, 0.300527,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 109.95, 0, 0, 0.455318,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1678.41, 0, 0, 0.534547,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.266621);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.299223, 1, 1, 0.607687,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 62.853, 0, -1, 0.370993,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 329.677, 0, 0, 0.395209,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1678.41, 0, 0, 0.473101,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.254636);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.757777,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.46341,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 311.983, 0, 0, 0.518089,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1411.33, 0, -1, 0.113424,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6586, 0, 0, 0.471515,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.487104,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.241471);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.00122516, -0.350485, -0.000897659, -0.00176225, -0.000227106, 0.000960813, -0.0145591, 0.0549562, -1, -0.04053, 0, 1, 0.929298,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.231831,-99) , 
8, 0.000380796, -0.948056, 0.000219994, 0.000138774, 0, 0.00117643, 0.0133889, 1.71019, 7, 0.254362, 0, 0, 0.328311,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.84713, 1, 0, 0.730357,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.525341,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0689556,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 24.3661, 0, 0, 0.481106,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 510.335, 0, 0, 0.495937,-99) , 
8, 0.000334585, 0, -0.000245609, 0, 0, 0, 0, -0.203418, 7, 0.0552465, 0, 0, 0.527348,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.136073);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.514433,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.19817,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6586, 0, 0, 0.487965,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.500831,-99) , 
NN(
0, 
0, 
8, -0.000450102, 0.0451383, 0.000400317, 0.00237587, 0, 0, 0, -0.190864, -1, 0.0367284, 0, -1, 0.0243833,-99) , 
8, 0.000460426, 0, -0.000392238, 0, 0, 0, 0, -0.214054, 7, -0.0983566, 0, 0, 0.481194,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.273953);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.882189,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453187,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.74798, 1, 0, 0.509631,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 105.873, 0, -1, 0.305186,-99) , 
8, 0.000483853, 0, -0.000473985, 0, 0, 0, 0, -0.150892, 7, -0.0487181, 0, 0, 0.442288,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.454928,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.142795);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.697945,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492841,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 311.983, 0, 0, 0.527233,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1411.33, 0, -1, 0.211297,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6586, 0, 0, 0.498282,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.508476,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.464071);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.876764,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.225009,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.23503, 0, 0, 0.822506,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.867548,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.366684,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 214.776, 0, 0, 0.46118,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.64517, 1, 0, 0.614718,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.749829,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.436264,-99) , 
8, -0.000518744, 0, 0.000465701, 0, 0, 0, 0, 0.279594, 7, 0.0399158, 0, 0, 0.57636,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1492.82, 0, -1, 0.24059,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 190.15, 0, 0, 0.467077,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.52242, 1, 0, 0.532357,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.421618);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.00119662, -0.270628, -0.000873717, -0.00182281, -0.000242202, 0.00101989, -0.0150618, -0.0258509, -1, -0.143319, 0, 1, 0.935807,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.369423,-99) , 
8, 0.000635927, 0.0632192, 8.50789e-05, -4.5813e-05, 0, 0.00122741, 0.103351, -1.80422, 7, 0.268325, 0, 0, 0.464783,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.84713, 1, 0, 0.783397,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.657966,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.338309,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.04792, 0, 0, 0.592857,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.60019,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0914342,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 27.7407, 0, 0, 0.439212,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 72.9797, 0, 0, 0.529839,-99) , 
8, 0.000471909, 0, -0.00035206, 0, 0, 0, 0, -0.281805, 7, 0.0809311, 0, 0, 0.56415,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.231642);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 87.2901, 0, 1, 0.894158,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.826818,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.387181,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 144.609, 0, 0, 0.495445,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.84713, 1, 0, 0.66864,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 112.139, 0, 1, 0.989631,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.447167,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.458511,-99) , 
8, 0.00078224, 0, -0.000667301, 0, 0, 0, 0, -0.316082, 7, 0.165459, 0, 0, 0.472982,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 310.854, 0, 0, 0.514056,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.312213);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1123.49, 0, 1, 0.969048,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.899162,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.215451,-99) , 
8, 0.0183167, -0.61887, -0.018108, -0.0192278, 0.00357443, 0.000600596, 0.252916, -1.04908, 7, 0.0555421, 0, 0, 0.529333,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 180.14, 0, 0, 0.718288,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 261.765, 0, 1, 0.594119,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1166.02, 0, -1, 0.384648,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 57.2444, 0, 0, 0.521479,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1934.35, 0, 0, 0.554965,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.177247);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1123.49, 0, 1, 0.95818,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.949844,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.25568,-99) , 
8, 0.0196507, -0.676247, -0.0193138, -0.0205595, 0.00285129, 0.000631295, 0.242948, -1.19154, 7, 0.11593, 0, 0, 0.539828,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 180.14, 0, 0, 0.714833,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
8, 0.000245007, 0, -0.000466026, 0, 0, 0, 0, 0.163547, -1, -0.138309, 0, -1, 0.481847,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 400.188, 0, 0, 0.497679,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1934.35, 0, 0, 0.531714,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.21856);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, -0.000175648, -0.153101, 0.000612598, -0.000167506, 0, 0.000928408, 0, -0.10576, -1, 0.140246, 0, 1, 0.801989,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0681355,-99) , 
8, 0.000975116, 0, -0.00135866, 0, 0, 0, 0, 0.495346, 7, -0.100274, 0, 0, 0.307496,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 468.415, 1, 0, 0.748007,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.66697, 0, 1, 0.853131,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.705109,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.477234,-99) , 
8, 0.000296353, 0, -0.000473717, 0, 0, 0, 0, 0.12562, 7, 0.0870152, 0, 0, 0.511335,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 362.574, 0, 0, 0.530197,-99) , 
8, 0.000497618, 0, -0.000360109, 0, 0, 0, 0, -0.304944, 7, 0.0816785, 0, 0, 0.565555,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.247219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.982381,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
8, 0.00203561, 0, -0.00132901, 0, 0, 0, 0, -1.36959, 7, -0.0788393, 0, 0, 0.916751,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.99773, 0, -1, 0.0410762,-99) , 
8, 0.00183264, 0, -0.000325512, 0, 0, 0, 0, -2.20915, 7, -0.195462, 0, 0, 0.795968,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2190.29, 0, 1, 0.581009,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.965833,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0306921,-99) , 
8, 0.000172761, 0.143192, -0.000380375, 0.00189935, 0.000457144, 0.000243577, -1.89232, 0.22596, 7, -0.0290673, 0, 0, 0.206202,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.434603, 0, 0, 0.570756,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299204, 1, 0, 0.587877,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.272651);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.00278364, 0, -0.00208939, 0, -0.000537942, -0.00104443, 0, -1.29019, -1, 0.069761, 0, 1, 0.915206,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.99773, 0, -1, 0.0510751,-99) , 
8, 0.00184272, 0, -0.000356445, 0, 0, 0, 0, -2.193, 7, -0.188619, 0, 0, 0.793143,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.984253,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0660581,-99) , 
8, 0.000779965, 0.152978, -0.000785668, 4.20187e-05, -0.000310027, -5.63081e-05, 0.721501, -1.21257, 7, -0.454366, 0, 0, 0.794481,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.593384,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.412624,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1312.76, 1, 0, 0.495426,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2190.29, 0, 0, 0.512274,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299204, 1, 0, 0.531683,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.43222);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.0097044, -1.774, -0.0106411, -0.0106801, 0.00257068, 0, -0.0126418, 2.00539, -1, -0.0164566, 0, 1, 0.985645,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.67906,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.191964,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.618525, 0, 0, 0.602669,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.492035, 1, 0, 0.646057,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.596104,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.202364,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2.84204, 1, 0, 0.554554,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.724948,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.157188,-99) , 
8, -0.00868982, 0, 0.00885886, 0, 0, 0, 0, 0.99358, 7, 0.212093, 0, 0, 0.347919,-99) , 
8, 0.000316696, 0, -0.000313583, 0, 0, 0, 0, -0.0889101, 7, -0.020767, 0, 0, 0.474603,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1678.41, 0, 0, 0.532397,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.417856);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
8, 0.00192875, 0, -0.00113327, 0, 0, 0, 0, -1.34136, -1, 0.021385, 0, 1, 0.781076,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.963482,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.38969,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 577.839, 1, 0, 0.44529,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.64517, 1, 0, 0.578749,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.878196,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.298145,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.897714, 0, 0, 0.682309,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.569921,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.283862,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.98739, 0, 0, 0.363709,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1922.95, 0, 0, 0.411241,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.52242, 1, 0, 0.479573,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.274459);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.63571,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.490672,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2.09436, 0, 0, 0.557982,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.7998,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0242709,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 133.39, 0, 0, 0.354087,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930.928, 0, 0, 0.532611,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.604717,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.153908,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1428.7, 0, 0, 0.229131,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 186.163, 0, 0, 0.283116,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.99439, 1, 0, 0.503531,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.346344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1590.67, 0, 1, 0.750033,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.814451,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.414955,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 214.776, 0, 0, 0.499705,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.64517, 1, 0, 0.601471,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.791968,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.385961,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.59854, 0, 0, 0.689006,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.727621,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.370087,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.747991, 1, 0, 0.410364,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1922.95, 0, 0, 0.450994,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.52242, 1, 0, 0.513293,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.40312);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.114003, 0, 1, 0.920126,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.624236,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.314797,-99) , 
8, 0.000427245, 0, -0.000384972, 0, 0, 0, 0, -0.203128, 7, -0.0575804, 0, 0, 0.565404,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.299223, 1, 0, 0.591123,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.792855,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.351267,-99) , 
8, -0.00229973, -0.345042, 0.00217507, 0, 0.00177482, 0, 0, 0.868327, 7, 0.098588, 0, 0, 0.542287,-99) , 
NN(
0, 
0, 
8, -0.000210222, 0.00447225, 0.00019627, 8.33054e-05, 0.000144486, 7.61723e-05, -0.0107429, -0.00536411, -1, -0.00126524, 0, -1, 0.00100349,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.04718, 0, 0, 0.443342,-99) , 
8, 0.000490752, 0, -0.000278969, 0, 0, 0, 0, -0.389116, 7, -0.0684158, 0, 0, 0.543086,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.343471);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.880035,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.102068,-99) , 
8, -0.00228571, -0.707553, 0.00245853, -0.00164051, 0.00308254, 0.00169466, 0, 1.51127, 7, -0.186469, 0, 0, 0.666781,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.727052,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.459266,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.85423, 0, 0, 0.495004,-99) , 
8, 0.000306674, 0, -0.00025552, 0, 0, 0, 0, -0.144601, 7, 0.0229051, 0, 0, 0.538368,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.595636,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.157502,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 701.756, 0, 0, 0.242679,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 186.163, 0, 0, 0.295349,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.99439, 1, 0, 0.509862,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.314892);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.922843,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0274219,-99) , 
8, 0.00221213, 0.0889653, -0.002911, -0.00126485, -0.000958796, 0.00101723, 0.28289, 0.152034, 7, -0.547026, 0, 0, 0.816553,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.623313,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.43906,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 66.357, 0, 0, 0.555369,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 348.046, 0, 0, 0.57921,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.941434,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.100085,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3.02947, 0, 0, 0.671134,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.546766,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.103626,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 665.269, 0, 0, 0.22263,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1438.26, 0, 0, 0.318755,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.99439, 1, 0, 0.550239,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.172735);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.897483,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0182764,-99) , 
8, 0.00244172, 0.0996367, -0.00306671, -0.00137671, -0.00100636, 0.00108228, 0.287716, -0.0852669, 7, -0.640338, 0, 0, 0.796746,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2204.98, 0, 1, 0.536002,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 348.046, 0, 0, 0.55749,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 39.0676, 1, -1, 0.271817,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 186.163, 0, 0, 0.322956,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2.99439, 1, 0, 0.532916,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.158522);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.871137,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0512979,-99) , 
8, 0.000976025, 0.253767, -0.00165087, 0.000699523, -0.000620299, -5.43887e-05, 0.25896, 0.226328, 7, -0.512544, 0, 0, 0.769435,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.909435,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.459578,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2177.27, 0, 0, 0.471206,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 318.945, 0, 0, 0.491019,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.498945,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.164508);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
8, 0.00109145, 0.268026, -0.00172892, 0.000691427, -0.000651171, 0.000296542, 0.267022, -0.0514694, -1, -0.000323318, 0, 1, 0.755062,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.582437,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45165,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1.5225, 1, 0, 0.508778,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 318.945, 0, 0, 0.524332,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.531239,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.145346);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 761.789, 1, 1, 0.543038,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.779408,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.139518,-99) , 
8, 0.00121719, -0.187292, -0.000552876, -0.0013663, 0, -0.0172087, 0.225557, -0.805338, 7, 0.15102, 0, 0, 0.340992,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 26.6586, 0, 0, 0.526932,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.533324,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.120074);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.808499,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0546672,-99) , 
8, 0.00119831, 0.289544, -0.00182414, 0.000712022, -0.000698563, 0.000635722, 0.276911, -0.282058, 7, -0.579205, 0, 0, 0.693374,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.891768,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.472007,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2177.27, 0, 0, 0.481912,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 318.945, 0, 0, 0.494569,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.500969,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.217913);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.850109,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48868,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2.29383, 1, 0, 0.574064,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.559188,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.243907,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1.69541, 1, 0, 0.4747,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2.09435, 0, 0, 0.520312,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 558.102, 0, 0, 0.526063,-99)    );
   return;
};
 
// Clean up
inline void ReadBDTMitFisher::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTMitFisher::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
